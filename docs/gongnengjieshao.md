## 第2章 Simplechain联盟链功能模块介绍
### 2.1 区块结构介绍

#### 2.1.1 区块头

#### 2.1.2 区块体

### 2.2 网络模块
由于高性能联盟链的TPS最高可达**20000**+TPS，区块链网络模块的负载增加，因此需要设计**新的拓扑**网络消息传输结构来进行消息的传递。在PBFT共识中，节点的角色分为**观察节点**与**共识节点**，观察节点与共识节点将根据不同的消息进行不同地网络拓扑，以在尽可能地降低共识节点网络载和保持网络健壮性之间找到平衡点。

#### 2.2.1 节点分类
在**Simpledger**网络中，节点有三中角色： 负责出块的**共识节点**，负责同步消息的**观察节点**,没有任何权限访问网络的**游离节点**。**Simpledger**通过智能合约和共识来区分、管理节点角色。

#### 2.2.2 节点加入网络

![RUNOOB_图标](images/addpeer.png)

如上图所示，当节点A主动加入节点B的网络中时，需要经历以下步骤：
```text

1： 节点A主动向节点B发起握手请求

2： 节点B在节点准入的智能合约中查询节点A的信息，如对方不在智能合约中拥有合法身份，则拒绝建立连接；反之，与节点A建立连接。

3：通过智能合约和共识，获得对方节点在网络中的index以统一的构建网络拓扑。

```

实际上在以上的步骤中，每个节点都会主动地将合约中的所有节点加入dailTask，主动地与对方建立连接已保证网络的完整性。而当游离节点主动请求加入合法网络时，则无法通过智能合约的认证机制，保证了网络安全性。

#### 2.2.3 交易同步方式
由于**Simpledger**在PBFT共识下的TPS可达20000+，因此需要对交易广播方式进行限制。由之前的每个节点全量广播交易变为按照树拓扑结构广播，使得总网络复杂度**O(n^2)**降低为**O(n)**。且由于在PBFT共识中，只有共识节点负责出块，所以交易消息将不会转发给观察节点，进一步降低网络负载。其网络拓扑如下：


![RUNOOB_图标](images/topology_consensus.png)


**共识节点**： 接收交易的**第一个共识节点**会将自身在整个共识节点网络中的index标记在交易里，并以自身的index为根构造网络拓扑，选择自身的index的子节点进行交易转发(附带了自身的index，表示树根)，如果所选子节点与自身没有建立网络连接，则将在此视图下接替子子节点的子节点，进行转发，如此反复。而收到了附带index的交易时，**观察节点**选择忽略(理论上不可能会有这个问题，导致此情况发生的情景可能为：将观察节点选举为共识节点，此时观察节点的状态还没有更新，而共识节点已经更新，并将交易转发给它，此情况下也可忽略，因为交易有多层措施来避免失败且是允许失败的)。**共识节点**会以交易附带的index为树根构造相同的网络拓扑，转发给在此视图下的自身的子节点。


**观察节点**： 而接收交易的**第一个观察节点**会随机选择一名共识节点并将该共识节点的index赋值给交易，将此交易转发给该共识节点。如果该共识节点没有与自身建立网络连接，则转发给该节点的子节点。

#### 2.2.3 区块账本同步方式
由于在**PBFT**共识中，节点拥有两种不同的身份: **共识节点**(负责达成共识出块)、**观察节点**(只负责同步区块信息)。且由于区块数据过大，如果按照原有的广播消息模型，观察节点很大的概率会向共识节点fetch最新的区块，最终所有的网络负载都将集中到共识节点上，导致共识节点网络超时，从而影响区块链的性能。

为了使共识节点出新块之后的单节点的网络复杂度从O(n)降低到O(1)。我们设计了一种树状的网络拓扑，和一种改进后的新块头消息体。网络拓扑如图：

![RUNOOB_图标](images/topology_newBlock.png)

新的块头消息体为

```go
type newBlockHashesData []struct {
Hash    common.Hash
Number  uint64
IsFetch uint8
}
```

由于新的块头消息除了使其他节点向自身fetch最新的区块信息，还可以改变自身在对方视图的状态。所以新的块头消息需要全量广播以更新最新的状态。新增字段**IsFetch**让对方节点感知是否可以向提供状态的节点进行fetch。而**IsFetch**默认为0，即默认只更新状态不进行fetch。只有当对方节点属于网络拓扑中的子节点时，此标记置为1，提示对方可以向自身fetch，从而降低网络负载。

而网络拓扑则是按照如下规则构建：

```text

1： 观察节点平摊给共识节点，如有j个观察节点，i个共识节点，则每个共识节点最多分配⌈j/i⌉个观察节点。

2： 共识节点在发送新的块消息体时，会同时选择共识子节点和观察子节点进行标记。而观察节点在发送新的块头消息时，只选择观察子节点进行标记。

3： 选择策略为：每个节点以自身为树根构造网络拓扑，选择自身的子节点，如子节点无法进行通信，则会接替子节点的任务，如此反复。

```

#### 2.2.4 定时更新状态

![RUNOOB_图标](images/status_old.png)
![RUNOOB_图标](images/status_new.png)

由于在**PBFT**共识中，两个共识节点会根据自身的视图投票。当其中一个节点出新块后，发送给另一个节点的新块消息如果因为网络原因丢失，则双方的视图可能为如图所示(consensus1: me: 100, other: 100; consensus2: me: 101,other: 100)，所以consensus1永远不会更新自身的状态，此时consensus1 会提议出第101个块，而consensus2会提议出102个块，导致共识瘫痪。因此需要增加新的消息体**NewPeerStatusMsg**保证双方状态的完全一致性。:

```go

type newPeerStatusData struct {
TD   uint64
Hash common.Hash
}

```

首先分析一下出现节点状态不一致的根本原因： **最新的新块消息没有发送到另外节点**。由于低状态的节点没有获得到已经是最新状态的节点的状态，即在它是视图中，没有感知到最新的状态。可以通过让旧的节点感知到最新的状态，以此来及时更新自身状态，最后所有节点达成共识。

流程如下：

```txt

1.每隔默认的状态同步时间(30s)， 节点比较对方peer的最新状态和30s之前的旧状态，如果对方peer的最新的状态更新了，则不进行任何操作。否则将自身的当前状态发送给对方。
2.当收到对方的状态消息时，如对方的状态是比当前视图的状态新的，则更新对方在自身视图的状态。如自身的状态比对方的状态新，则代表对方没有接收到自身之前发送的新块头消息，则发送自身的状态消息。
3.最终所有的节点都能获得最新的状态消息，从而更新自身状态。

```



### 2.3 存储模块
#### 2.3.1数据库类型

#### 2.3.2存储整体结构

#### 2.3.3 世界状态树

simplechain链中所有的账户信息都体现在世界状态之中，并由世界状态树保存。如果你想知道某一账户的余额，或者某智能合约当前的状态，就需要通过查询世界状态树来获取该账户的具体状态信息。账户分为两种：

- **外部账户(Externally owned account)：**
被私钥控制且没有任何代码与之关联。一个外部账户可以创建交易，来发送消息给另一个外部账户或合约账户，以此来触发转账交易和智能合约的调用、创建。
- **合约账户(Contract account)：**
被它们的合约代码控制且有代码与之关联。合约账户不可以自己发起一个交易，只能被外部账户调用。

![RUNOOB 图标](images/sjzts.png)

- **nonce：**
从此地址发送出去的交易数量或者此账号产生的合约创建操作。
- **balance：**
此账号所拥有的gas数量。
- **storageRoot：**
账户存储树的根节点哈希值。
- **codeHash：**
对于合约账户，就是此账户存储 EVM 代码的哈希值。对于 EOA 账户此处留空。

#### 2.3.4 账户状态树
账户存储树是保存与账户相关联数据的结构。该项只有合约账户才有，而在 EOA 中，storageRoot 留空、 codeHash 则是一串空字符串的哈希值。所有智能合约的数据都以 32 字节映射的形式保存在账户存储树中。账户状态中的 storageRoot区域负责维持账户存储树根节点哈希值。可以理解为保存Solidity智能合约中的状态变量值。

![RUNOOB 图标](images/zhzts.png)

多个区块的MPT树共享了账户状态，子块状态树和父块状态树的差别在于它指向了在子区块中被改变了的账户。这样节省了总的存储空间，方便了块的回滚操作。例如某个智能合约账户中，智能合约的变量值由29改变成了45。

![RUNOOB 图标](images/zhzts2.png)

#### 2.3.5 总结

### 2.4 交易模块
#### 2.4.1 交易数据结构
外部账户可以创建交易,用自己的私钥进行签名之发送消息给另一个外部账户或合约账户。两个外部账户之间传送的消息即为转账操作。从外部账户到合约账户的消息会激活合约账户的代码，执行各种操作，也就是我们常说的调用智能合约。可以通过向0地址发起交易来创建合约账户。交易包含以下主要字段：

字段 | 说明
---|---
Type | 交易的类型，ContractCreation（创建合约）还是MessageCall（调用合约或转账）
FromAddress | 发送交易的账户地址
ReceiveAddress | 接受方地址
Value | 向目标账户发送的金额
Data | 交易的附加数据
GasPrice | 为交易付出的Gas价格
Gas | 为交易付出的Gas
Nonce | 发送地址的随机数
Blocklimit | 交易过期的区块高度
VRS | 交易签名结构体

#### 2.4.2 收据数据结构
账户创建交易并向其它节点广播后，会被其它节点执行并放入准备打包的区块。在这个过程中会生成一个收据。收据的主要字段有：

字段 | 说明
---|---
blockHash | 交易所在块的哈希值
blockNumber | 交易在块的序号
transactionHash | 交易的哈希值
transactionInde | 交易在块中的序号
from | 发送者地址
to | 接受者地址，为空时候表示创建合约
cumulativeGasUsed | 执行完此交易时候，块内消耗的总的gas值
gasUsed | 本交易所消耗的gas
contractAddress | 当此交易为创建合约时，表示所创建合约的地址，否则为空
logs | 此交易的日志

#### 2.4.3 交易流程
交易——区块链系统的核心，负责记录区块链上发生的一切。区块链引入智能合约后，交易便超出价值转移的原始定义，其更加精准的定义应该是区块链中一次事务的数字记录。无论大小事务，都需要交易的参与。

![RUNOOB 图标](images/jylc.png)

##### 交易发起
用户的请求给到客户端后，客户端会构建出一笔有效交易，交易中包括以下关键信息：
- 发送地址：即用户自己的账户，用于表明交易来自何处。
- 接收地址：交易分为三类，一类是部署合约的交易，一类是调用合约的交易。一类是转账交易，前者，由于交易并没有特定的接收对象，因此规定这类交易的接收地址固定为0x0；后者，则需要将交易的接收地址置为链上合约的地址。
- 交易相关的数据：一笔交易往往需要一些用户提供的输入来执行用户期望的操作，这些输入会以二进制的形式被编码到交易中。
- 交易签名：为了表明交易确实是由自己发送，用户会向SDK提供私钥来让客户端对交易进行签名，其中私钥和用户账户是一一对应的关系。

之后，区块链客户端会再向交易填充一些必要的字段，如用于防交易重放的交易nonce及blockLimit。交易构造完成后，客户端随后便通过RPC信道将交易发送给节点。

![RUNOOB 图标](images/jjfq.png)

##### 交易池
区块链交易被发送到节点后，节点会通过验证交易签名的方式来验证一笔交易是否合法。若一笔交易合法，则节点会进一步检查该交易是否重复出现过，若从未出现过，则将交易加入交易池缓存起来。若交易不合法或交易重复出现，则将直接丢弃交易。

![RUNOOB 图标](images/jyc.png)

##### 交易打包
为了提高交易处理效率，同时也为了确定交易之后的执行顺序保证事务性，当交易池中有交易时，Sealer线程负责从交易池中按照先进先出的顺序取出一定数量的交易，组装成待共识区块，随后待共识区块会被发往各个节点进行处理。

![RUNOOB 图标](images/jyc.png)

##### 交易执行
节点在收到区块后，会调用区块验证器把交易从区块中逐一拿出来执行。执行引擎就会把交易交给EVM（以太坊虚拟机）执行。

交易可能会执行成功，也可能因为逻辑错误或Gas不足等原因执行失败。交易执行的结果和状态会封装在交易回执中返回。

![RUNOOB 图标](images/jyzx.png)

##### 交易共识
区块链要求节点间就区块的执行结果达成一致才能出块。一般采用PBFT共识保证整个系统的一致性。具体共识描述见共识机制模块。

##### 交易落盘
在共识出块后，节点需要将区块中的交易及执行结果写入硬盘永久保存，并更新区块高度与区块哈希的映射表等内容，然后节点会从交易池中剔除已落盘的交易，以开始新一轮的出块流程。用户可以通过交易哈希等信息，在链上的历史数据中查询自己感兴趣的交易数据及回执信息。

### 2.5 共识机制模块
在公链上，常见的共识算法有POW、POS、DPOS，而联盟链中一般为POA、RAFT、PBFT共识等。

#### 2.5.1 PBFT共识
BFT（拜占庭将军问题）是分布式计算中的一个经典问题。问题描述为，几位拜占庭将军分别率领部队合力包围了一座城市。他们必须一致决定是否发起攻城。如果一些将军在没有其他将军参与的情况下决定发起攻城，那么他们的行动将以失败告终。将军们之间相互隔着一定的距离，必须依靠信息传递进行交流。首个提出的该问题解决方案称为“实用拜占庭容错”（PBFT）

##### 核心流程
PBFT共识主要包括Pre-prepare、Prepare和Commit三个阶段：

![RUNOOB 图标](images/pbft.png)

- Pre-prepare：负责执行区块，产生签名包，并将签名包广播给所有共识节点；
- Prepare：负责收集签名包，某节点收集满2*f+1的签名包后，表明自身达到可以提交区块的状态，开始广播Commit包；
- Commit：负责收集Commit包，某节点收集满2*f+1的Commit包后，直接将本地缓存的最新区块提交到数据库。

##### leader打包区块
PBFT共识算法中，共识节点轮流出块，每一轮共识仅有一个leader打包区块，节点计算当前leader索引与自己索引相同后，就开始打包区块。区块打包主要由PBFTSealer线程完成，Sealer线程的主要工作如下图所示：

![RUNOOB 图标](images/pbft1.png)

- **产生新的空块:**
通过区块链(BlockChain)获取当前最高块，并基于最高块产生新空块(将新区块父哈希置为最高块哈希，时间戳置为当前时间，交易清空)；
- **从交易池打包交易:**
产生新空块后，从交易池中获取交易，并将获取的交易插入到产生的新区块中；
- **组装新区块:**
Sealer线程打包到交易后，将新区块的打包者(Sealer字段)置为自己索引，并根据打包的交易计算出所有交易的transactionRoot；
- **产生Prepare包:**
将组装的新区块编码到Prepare包内，通过PBFTEngine线程广播给组内所有共识节点，其他共识节点收到Prepare包后，开始进行三阶段共识。

##### pre-prepare阶段
共识节点收到Prepare包后，进入pre-prepare阶段，此阶段的主要工作流程包括：

- **Prepare包合法性判断：**
主要判断是否是重复的Prepare包、Prepare请求中包含的区块父哈希是否是当前节点最高块哈希(防止分叉)、Prepare请求中包含区块的块高是否等于最高块高加一；
- **缓存合法的Prepare包:** 若Prepare请求合法，则将其缓存到本地，用于过滤重复的Prepare请求；
- **空块判断：**
若Prepare请求包含的区块中交易数目是0，则触发空块视图切换，将当前视图加一，并向所有其他节点广播视图切换请求；
- **执行区块并缓存区块执行结果:**
若Prepare请求包含的区块中交易数目大于0，则调用BlockVerifier区块执行器执行区块，并缓存执行后的区块；
- **产生并广播签名包：**
基于执行后的区块哈希，产生并广播签名包，表明本节点已经完成区块执行和验证。

##### Prepare阶段
共识节点收到签名包后，进入Prepare阶段，此阶段的主要工作流程包括：

- **签名包合法性判断：**
主要判断签名包的哈希与pre-prepare阶段缓存的执行后的区块哈希相同，若不相同，则继续判断该请求是否属于未来块签名请求(产生未来块的原因是本节点处理性能低于其他节点，还在进行上一轮共识，判断未来块的条件是：签名包的height字段大于本地最高块高加一)，若请求也非未来块，则是非法的签名请求，节点直接拒绝该签名请求；
- **缓存合法的签名包：**
节点会缓存合法的签名包；
- **判断pre-prepare阶段缓存的区块对应的签名包缓存是否达到2f+1，**
若收集满签名包，广播Commit包：若pre-prepare阶段缓存的区块哈希对应的签名包数目超过2*f+1，则说明大多数节点均执行了该区块，并且执行结果一致，说明本节点已经达到可以提交区块的状态，开始广播Commit包；
- **若收集满签名包，备份pre-prepare阶段缓存的Prepare包落盘：**
为了防止Commit阶段区块未提交到数据库之前超过2*f+1个节点宕机，这些节点启动后重新出块，导致区块链分叉(剩余的节点最新区块与这些节点最高区块不同)，还需要备份pre-prepare阶段缓存的Prepare包到数据库，节点重启后，优先处理备份的Prepare包。

##### Commit阶段
共识节点收到Commit包后，进入Commit阶段，此阶段工作流程包括：

- **Commit包合法性判断：**
主要判断Commit包的哈希与pre-prepare阶段缓存的执行后的区块哈希相同，若不相同，则继续判断该请求是否属于未来块Commit请求(产生未来块的原因是本节点处理性能低于其他节点，还在进行上一轮共识，判断未来块的条件是：Commit的height字段大于本地最高块高加一)，若请求也非未来块，则是非法的Commit请求，节点直接拒绝该请求；
- **缓存合法的Commit包：**
节点缓存合法的Commit包；
- **判断pre-prepare阶段缓存的区块对应的Commit包缓存是否达到2f+1，若收集满Commit包，则将新区块落盘：**
若pre-prepare阶段缓存的区块哈希对应的Commit请求数目超过2f+1，则说明大多数节点达到了可提交该区块状态，且执行结果一致，则调用BlockChain模块将pre-prepare阶段缓存的区块写入数据库；

#### 2.5.2 优化后的PBFT

### 2.6 智能合约模块
#### 2.6.1 智能合约的概念
智能合约（smart contract）这个术语至少可以追溯到 1995 年，是由多产的跨领域法 律学者尼克·萨博（Nick Szabo）提出来的。他的定义是“一个智能合约是一套以数字形式定义的承诺（promises），包括合约参与方可以在上面执行这些承诺的协议。”

- **承诺：**
一套承诺指的是合约参与方同意的（经常是相互的）权利和义务。这些承诺定义了合约 的本质和目的。以一个销售合约为典型例子。卖家承诺发送货物，买家承诺支付合理的货款。
- **数字形式：**
数字形式意味着合约不得不写入计算机可读的代码中。这是必须的，因为只要参与方达成协定，智能合约建立的权利和义务，是由一台计算机或者计算机网络执行的。
- **达成协定：**
智能合约的参与方什么时候达成协定呢？答案取决于特定的智能合约实施。一般而言，当参与方通过在合约宿主平台上安装合约，致力于合约的执行时，合约就被发现了。
- **合约执行：**
“执行”的真正意思也依赖于实施。一般而言，执行意味着通过技术手段积极实施。
- **计算机可读的代码：**
另外，合约需要的特定“数字形式”非常依赖于参与方同意使用的协议。
- **协议：**
协议是技术实现（technical implementation），在这个基础上，合约承诺被实现， 或者合约承诺实现被记录下来。选择哪个协议取决于许多因素，最重要的因素是在合约履行期间，被交易资产的本质。

智能合约，就是一段写在区块链上的代码，一旦某个事件触发合约中的条款，代码即自动执行。也就是说，满足条件就执行，管他愿不愿意。

#### 2.6.2 智能合约的工作原理
智能合约是一段写在区块链上的代码，智能合约的工作原理如下：
构建 → 存储 → 执行
- 1）智能合约由区块链内的多个用户共同参与制定，可用于用户之间的任何交易行为。协议中明确了双方的权利和义务，开发人员将这些权利和义务以电子化的方式进行编程，代码中包含会触发合约自动执行的条件。比方说，你把一套闲置的房子租给A，那么，这份智能租约中就规定了A必须在每月5号之前给你打房租、你必须在收到房租时马上给对方钥匙等条款。
- 2）一旦编码完成，这份智能合约就被上传到区块链网络上，即全网验证节点都会接收到你和A的租房合约。
- 3）智能合约会定期检查是否存在相关事件和触发条件；满足条件的事件将会推送到待验证的队列中。假设A在4号提前打房租给你，这个事件就成了该合约的触发条件（每月5号以前）。
- 4）区块链上的验证节点先对该事件进行签名验证［3］，以确保其有效性；等大多数验证节点对该事件达成共识后，智能合约将成功执行，并通知用户。
- 5）成功执行的合约将移出区块。而未执行的合约则继续等待下一轮处理，直至成功执行。

#### 2.6.3 虚拟机EVM
EVM是一个轻量级的虚拟机，其设计是用于在simplechain网络上运行智能合约。虚拟机(VM）是建立在本机操作系统上模拟物理机的高级抽象。同时它也是一个“堆栈机”和一个“状态机”，它是一台可以读取输入并基于这些输入转换为新状态的机器，也是将内存结构组织为堆栈并作为堆栈访问的虚拟机。EVM不仅是沙盒封装的，而且是完全隔离的，作为区块验证协议共识算法的一部分，参与网络的每个节点都会运行EVM。

#### 2.6.4 Simplechain智能合约

- **Solidity：**
智能合约默认的编程语言，文件扩展名以.sol结尾。Solidity是一种语法类似JavaScript的高级语言。它被设计成以编译的方式生成simplechain联盟链虚拟机代码。
- **合约事件：**
simplechain联盟链中的事件是一个simplechain联盟链日志和事件监测协议的抽象，日志记录提供合约的地址，事件则利用现有的ABI功能来解析日志记录。对合约事件的监听，可以在业务上实现部分自动化的操作。
- **权限管理：**
通过合约接口实现，simplechain联盟链网络的加入和退出，需要通过管理节点的申请、投票，符合半数以上节点通过原则，方可加入或退出网络。
- **角色管理：**
通过合约接口实现，普通节点升级为管理员节点或管理员节点降级为普通节点都需要通过管理员节点的审核，符合半数以上节点通过原则，方可完成角色的转变。降级为普通角色的节点将失去对网络的部分管理权限。
- **合约生命周期管理：**
实现合约的升级、冻结等功能。

### 2.7 账户模块
#### 2.7.1 账户的作用
账户在simplechain联盟链里发挥着中心作用。所有账户的状态代表simplechain联盟链网络的状态，simplechain联盟链坊网络会和每一个区块一起更新，网络需要达成关于simplechain联盟链的共识。账户和账户对应的签发证书代表外部代理人的身份，账户运用非对称加密的私钥文件来签署交易的同时并验证账户对应的签发证书的合法性，以便EVM虚拟机可以安全验证交易发送者的身份。

#### 2.7.2 合约账户
合约账户简称为合约，由智能合约的代码控制。只有合约账户才有代码，其中存储的是codeHash（这个账户的EVM虚拟机代码的哈希值）。这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。

合约账户不能主动发起交易，只能在被触发后按预先编写的智能合约代码执行。合约账户有账户余额、有代码、能被出发执行智能合约代码、在智能合约创建后自动运行。

#### 2.7.3 外部账户
外部账户代表着外部代理人（例如人物角色，节点，或是自动代理人）的身份。

每个外部账户都由一对密钥来定义，包括私钥文件、证书文件以及CA根证书。账户以地址为索引，地址由证书文件里的公钥生成，每对私钥/地址都编码在一个私钥文件（JSON文件）中，其中最重要的为账户私钥，通常用创建账户时的密码加密。使用外部账户发起交易之前需要校验签发证书的合法性以及账户解锁。

外部账户可以触发交易。外部账户有账户余额、无代码、能触发交易（转账或执行智能合约）、由私钥文件、证书文件以及根证书文件控制。